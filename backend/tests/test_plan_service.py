import pytest
import os
import json
from unittest.mock import patch, MagicMock
from app.services.plan_service import generate_plan, get_plan
from app.models import Plan, Graph, Node, Edge, Idea
from app.storage import save_plan_markdown, load_plan_markdown, save_idea
from app.config import PLANS_DIR, IDEAS_DIR
from fastapi import HTTPException

@pytest.fixture(autouse=True)
def setup_teardown():
    os.makedirs(PLANS_DIR, exist_ok=True)
    os.makedirs(IDEAS_DIR, exist_ok=True)
    yield
    for d in [PLANS_DIR, IDEAS_DIR]:
        for f in os.listdir(d):
            if f.endswith(".json") or f.endswith(".md"):
                os.remove(os.path.join(d, f))

@pytest.mark.asyncio
async def test_generate_plan():
    mock_graph = Graph(
        nodes=[Node(id="1", label="Idea", type="idea")],
        edges=[]
    )
    mock_llm_response = "# My Test Plan\n\nThis is a test plan generated by the LLM."

    with patch('app.services.llm_client.LLMClient.send_prompt', return_value=mock_llm_response) as mock_send_prompt:
        plan_markdown = await generate_plan(mock_graph)
        assert plan_markdown == mock_llm_response
        mock_send_prompt.assert_called_once()
        
        # Verify the prompt content
        call_args = mock_send_prompt.call_args[0][0]
        assert "{{graph_json}}" not in call_args # Should be replaced
        assert json.dumps(mock_graph.model_dump(), indent=2) in call_args

@pytest.mark.asyncio
async def test_get_plan_existing():
    idea_id = "test_existing_plan"
    expected_markdown = "# Existing Plan\n\nThis plan already exists."
    save_plan_markdown(Plan(idea_id=idea_id, markdown=expected_markdown), PLANS_DIR)

    plan = await get_plan(idea_id)
    assert isinstance(plan, Plan)
    assert plan.idea_id == idea_id
    assert plan.markdown == expected_markdown

@pytest.mark.asyncio
async def test_get_plan_generate_new():
    idea_id = "test_new_plan"
    idea_text = "A new idea to plan."
    idea = Idea(id=idea_id, text=idea_text, answers={"Q1": "A1"})
    save_idea(idea, IDEAS_DIR)

    mock_graph = Graph(
        nodes=[Node(id=idea_id, label=idea_text, type="idea")],
        edges=[]
    )
    mock_llm_response = "# Newly Generated Plan\n\nThis plan was just created."

    with patch('app.services.plan_service.load_plan_markdown', return_value=None), \
         patch('app.services.plan_service.build_graph', return_value=mock_graph) as mock_build_graph, \
         patch('app.services.llm_client.LLMClient.send_prompt', return_value=mock_llm_response) as mock_send_prompt:
    
        plan = await get_plan(idea_id)
        assert isinstance(plan, Plan)
        assert plan.idea_id == idea_id
        assert plan.markdown == mock_llm_response
        
        mock_build_graph.assert_called_once_with(idea_id)
        mock_send_prompt.assert_called_once()

        # Verify the new plan was saved
        loaded_markdown = load_plan_markdown(idea_id, PLANS_DIR)
        assert loaded_markdown == mock_llm_response

@pytest.mark.asyncio
async def test_get_plan_idea_not_found_for_graph_build():
    # If build_graph raises HTTPException (e.g., idea not found), get_plan should propagate it
    with patch('app.services.plan_service.load_plan_markdown', return_value=None), \
         patch('app.services.plan_service.build_graph', side_effect=HTTPException(status_code=404, detail="Idea not found.")) as mock_build_graph:
        with pytest.raises(HTTPException) as exc_info:
            await get_plan("non_existent_idea_for_plan")
        assert exc_info.value.status_code == 404
        assert exc_info.value.detail == "Idea not found."
        mock_build_graph.assert_called_once_with("non_existent_idea_for_plan")
